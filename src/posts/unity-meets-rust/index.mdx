---
title: "Unity meets Rust - The Case for Hybrid Game Development"
draft: false
date: 2025-07-04
tags: ["rust", "unity", "gamedev"]
---

Almost 20 years after I first learned programming, I still get the occasional brain worm telling me to go do game development.

So every once in a while I dabble in some unknown framework, not with the intent of actually shipping something (maybe someday, or at least that's what I tell myself), but at least with the goal of learning something new.

I did a couple of 2-day sprints recently to learn Svelte and three.js by making a [snake-like game](http://snake.naps62.com). Later I finally learned Bevy by making [Space Invaders](https://space-invaders.naps62.com).

But it's been a few years since I touched Unity or any other more appropriate framework for actually shipping games.

TODO: Add screenshots of the snake game and Space Invaders

## The eternal gamedev dilemma

Here's the thing: I don't actually know what it takes to ship a game (I haven't published one), but I see a lot of discussion online in the gamedev world about how Bevy and full-on ECS for gamedev might be a bit misguided.

The argument, mainly from people like Casey Muratori and Jonathan Blow, is that game development requires the ability to be creative and quickly iterate on new ideas – something that Rust fundamentally does not allow for.

So I'm conflicted. I want to build games. Do I want to actually ship a game, and therefore should I go full-on Unity, even though:
- Unity's editor feels sluggish compared to my usual development workflow
- Script changes require waiting for the UI to reload
- Unity doesn't play well with Wayland on Linux, meaning I have to compromise on my setup

Or do I want the enjoyment of building a never-to-be-finished game, and play with all the cool toys the Bevy and Rust communities are building?

Well, this is a story of how I spent way too much free time not doing either, but giving myself the possibility of someday doing both... someday.

## The best of both worlds

Let's break down what attracts me to each approach:

### Unity's strengths:
- Mature ecosystem with tons of resources
- Visual editor that's actually useful for layouts, animations, and assets
- Large community of developers who've actually shipped games
- Established workflows that have proven to work at scale

### Rust/Bevy's strengths:
- The development experience I'm used to: fast feedback loops, great tooling, strong type system
- Unit tests that run instantly and tell me what I broke
- No waiting for editor reloads or hitting play buttons to debug
- Modern architecture patterns that make sense to me

### The problem with each:
- **Unity**: Editor-driven development feels like a slog. I'm used to near-instant feedback from LSPs, and the Unity workflow breaks that flow.
- **Bevy**: It moves the needle from "building a game" to "building a game framework." In my Space Invaders project, I struggled with mechanics that would be trivial in Unity.

TODO: Add a comparison table or infographic here

## What if we could have both?

More concretely, what if I could build the core logic of a game in Rust, completely decoupled from any rendering engine, where I could test everything thoroughly, while leaving Unity to handle only what it's actually good at: visuals, inputs, animations, and asset management?

This leads us to a simple but powerful concept.

## The game core concept

I'm obviously not the first to think about this. I found several `runity` GitHub repos attempting Unity + Rust integration. Most aimed to reimplement every Unity function via Rust (admittedly, both projects appear abandoned – perhaps because this is neither easy nor in high demand).

But we can attempt something much simpler. And from that simplicity, some interesting ideas emerge.

Think about it like a web developer: imagine our game as two components:
- **The backend**: where all the state and business logic lives
- **The frontend**: where inputs come from, and where we draw pretty things

While this isn't unheard of, it's not as popular in gamedev as it is in web development. Even multiplayer games, where there's literally a client-server architecture, blur the lines for performance reasons.

TODO: Add a simple architecture diagram showing the separation

## Interface agnostic development

This idea actually crystallized when I was playing Patrick's Parabox recently. The game has an ASCII mode that works surprisingly well – same gameplay, completely different presentation.

TODO: Add screenshots of Patrick's Parabox in both visual and ASCII modes 

If we achieve complete decoupling of game logic and rendering, we can hot-swap rendering engines, potentially making the same gameplay available across multiple mediums. Terminal version, anyone?

This approach works particularly well for certain types of games:
- **Puzzle games**: Rules are clearly defined and deterministic
- **Turn-based games**: No real-time pressure, everything can be computed step by step
- **Strategy games**: Complex logic that benefits from thorough testing

These genres benefit from:
- Clear, testable game rules
- Deterministic behavior
- Less reliance on timing-critical events
- Logic that can be complex enough to warrant the separation

## Unexpected benefits

Once you have a clean game core, some interesting possibilities emerge:

### AI-powered testing
I can plug AI agents directly into the game core, have them learn to play, and then use those models as unit tests. Imagine statically guaranteeing that all your levels are beatable, or that your game balance is within expected parameters.

### Deterministic replay systems
With all state changes flowing through a clean API, implementing replay systems becomes trivial. Perfect for debugging, testing, and even creating demo content.

### Cross-platform consistency
The same core logic can power a mobile version, a desktop version, and even a web version, all with platform-specific UIs but identical game behavior.

TODO: Add examples of games that do this well

## Where do we go from here?

This is clearly just the beginning of the conversation. The real question is: how do we actually build this setup?

In the next post, I'll dive into the technical details of creating a hybrid Unity + Rust development environment that actually works. We'll cover:

- Setting up automatic DLL reloading in Unity
- Building Rust libraries for multiple platforms (including the WebAssembly gotchas)
- Creating a development workflow that gives you the best of both worlds
- Real code examples and configuration files

But for now, I'm curious: does this approach resonate with you? Are you also frustrated with the current state of game development tooling? Have you tried similar hybrid approaches?

TODO: Add a call-to-action for feedback and discussion 

---

*This is Part 1 of a 2-part series on hybrid game development. Part 2 will focus on the technical implementation details and actual code examples.*
