---
title: "Unity meets Rust - Building the Perfect Development Setup"
draft: false
date: 2025-07-04
tags: ["rust", "unity", "gamedev", "tooling"]
---

[s1]: https://rjgameiro.medium.com/let-fun-rust-unity-f7f62609ba49
[s2]: https://www.youtube.com/watch?v=L7M_vbo1N2g&t=315s
[s3]: https://testdouble.com/insights/integrating-rust-with-unity-for-better-performance
[s4]: https://www.resolutiongames.com/blog/calling-rust-from-c-in-unity

I spend a huge amount of time *not* building games. This includes time spent in my actual work (not games), as well as all those times I try to sneak into gamedev as a hobby, only to be quickly sidetracked to bikeshed the most niche of issues anyone could come up with.

This time, I decided I wanted to *not* build a game, not just in a framework, but in two completely different stacks at the same time.

There are actually some high-level reasons why someone might want to do that, but I'll leave those for a future post. This one is for the misguided and purely technical timesinks.

The good news is that while I don't have anything resembling a finished game, I do have a working development environment that gives me the best of both worlds: the rapid iteration of Rust development with the visual power of Unity.

Here's how I built it.

## The setup

I was conflicted between Unity, where I'd have to deal with C# and a GUI-driven workflow, or Rust and Bevy, where I'd be in much more familiar territory, but without the prototyping flexiblity you typically want while trying to figure out what you're building.

So naturally I picked both.

I decided it would be fun to explore interop between the two sides: using Rust and Bevy to build the core game logic, completely abstracted away from any rendering and input devices, and plug that into Unity where I'd handle those details, which are the part I actually prever a GUI editor for.

This works better for certain types of games, such as puzzle or turn-based, where everything is deterministic, and we don't have to deal with physics, real-time, and RNG to add noise to our system.

TODO: images of patrick's parabox and other games

But how can we achieve this?

## FFI

To get two languages to talk to each other, Foreign Function Interface (FFI) is the usual approach. For Rust -> Unity C#, this looks like this:

```rust
#[unsafe(no_mangle)]
pub extern "C" fn add(u32 x, u32 y) -> u32 {
    x + y
}
```

```csharp
using System.Runtime.InteropServices;

// in windows, will look for "game_core.dll"
// in macOS, will look for "libgame_core.dylib"
// in Linux, will look for "libgame_core.so"
[DllImport("game_core")]
private static extern int add(int x, int y);
```

We need 3 key things:
- `no_mangle` ensure the final symbol is called exactly `add`, without any mangling typically added by compilers to avoid name collisions
- `extern "C"` tells Rust to ensure the function is compatible with C-style libraries, which is necessary for FFI
- `DllImport` is the .NET side's way of importing a dynamically-linked library. Depending on the platform, a specific file will be loaded into memory, which is expected to contain the compile code for the linked functions

## Building a multi-platform rust library

For each platform, we need to compile for a different Rust target

| Platform | Target | Crate type |
|---|---|---|
| WebGL | wasm32-unknown-emscripten|
| Windows | x86_64-pc-windows-gnu |

Android (ARM64) aarch64-linux-android

rustup target add wasm32-unknown-emscripten # WebGL with EMScripten
rustup target add aarch64-linux-android     # Android on ARM 64 bits
rustup target add armv7-linux-androideabi   # Android on ARM 32 bits
rustup target add aarch64-apple-darwin      # macOS on Apple Silicon
rustup target add x86_64-apple-darwin       # macOS on Intel
rustup target add aarch64-apple-ios         # iOS

`

In Unity, these libraries need to be placed into `Assets/Plugins`, to play nice with the asset pipeline. So let's :


Before diving into solutions, let's identify the main technical hurdles:

1. **Unity doesn't support hot-reloading of native libraries**
2. **Building for multiple platforms requires different compilation targets**
3. **WebAssembly is especially tricky** (thanks, Rust 1.87)
4. **The feedback loop needs to be fast** to maintain developer sanity

The solution involves three main components that work together to create a seamless development experience.

## Challenge 1: Auto-reloading DLLs

Unity's limitation here is well-known: once it loads a native library, it holds onto it until the editor restarts. This kills the fast iteration cycle we want.

My workaround is inspired by several existing solutions, but I took it a step further. The key insight is to generate a new library file with a timestamp for each build, tricking Unity into loading a "new" library each time.

TODO: Add a diagram showing the library loading process

Here's the core script that handles this:

```bash
#!/bin/bash
# auto-reload-dll.sh

TIMESTAMP=$(date +%s)
RUST_PROJECT_PATH="./game-core"
UNITY_PLUGINS_PATH="./unity-project/Assets/Plugins"

# Build the Rust library
cd $RUST_PROJECT_PATH
cargo build --release

# Copy with timestamp
cp target/release/libgame_core.so $UNITY_PLUGINS_PATH/libgame_core_$TIMESTAMP.so

# Update the C# wrapper to load the new library
sed -i "s/libgame_core_[0-9]*/libgame_core_$TIMESTAMP/g" \
    ../unity-project/Assets/Scripts/GameCoreWrapper.cs

echo "Library reloaded: libgame_core_$TIMESTAMP.so"
```

The C# side looks like this:

```csharp
// GameCoreWrapper.cs
using System;
using System.Runtime.InteropServices;

public class GameCoreWrapper
{
    // This gets automatically updated by the build script
    private const string LIB_NAME = "libgame_core_1641234567";
    
    [DllImport(LIB_NAME)]
    private static extern void initialize_game();
    
    [DllImport(LIB_NAME)]
    private static extern void update_game(float deltaTime);
    
    [DllImport(LIB_NAME)]
    private static extern IntPtr get_game_state();
    
    // Public interface
    public static void Initialize() => initialize_game();
    public static void Update(float deltaTime) => update_game(deltaTime);
    public static GameState GetState() => ParseGameState(get_game_state());
    
    // Helper to parse the game state from Rust
    private static GameState ParseGameState(IntPtr ptr)
    {
        // JSON deserialization or custom parsing
        // depending on your data format
    }
}
```

Yes, this means that over a long development session, the Unity editor accumulates many loaded libraries. But in practice, a single editor restart every few hours is much better than restarting after every change.

## Challenge 2: Multi-platform builds

Different platforms require different compilation approaches. Here's my `Cargo.toml` setup:

```toml
[package]
name = "game-core"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[target.'cfg(target_os = "android")'.dependencies]
jni = "0.21"

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"

[profile.release]
lto = true
codegen-units = 1
panic = "abort"
```

The build script handles each platform:

```bash
#!/bin/bash
# build-all-platforms.sh

set -e

TARGETS=(
    "x86_64-pc-windows-gnu"
    "x86_64-apple-darwin"
    "aarch64-apple-darwin"
    "x86_64-unknown-linux-gnu"
    "aarch64-linux-android"
    "armv7-linux-androideabi"
    "wasm32-unknown-unknown"
)

for target in "${TARGETS[@]}"; do
    echo "Building for $target..."
    
    if [[ $target == "wasm32-unknown-unknown" ]]; then
        # WebAssembly needs special handling
        cargo build --target $target --release
        wasm-bindgen --out-dir pkg --target web \
            target/wasm32-unknown-unknown/release/game_core.wasm
    else
        cargo build --target $target --release
    fi
    
    echo "âœ“ $target complete"
done
```

## Challenge 3: WebAssembly gotchas

WebAssembly deserves special mention because it's been particularly painful. Since Rust 1.87, the compiler generates WASM features that Unity's linker doesn't support yet.

The workaround is to use an older target specification:

```toml
# In .cargo/config.toml
[target.wasm32-unknown-unknown]
rustflags = [
    "-C", "target-feature=-simd128",
    "-C", "target-feature=-bulk-memory",
    "-C", "target-feature=-mutable-globals"
]
```

TODO: Add a note about Unity's WebAssembly support roadmap

## Challenge 4: The glue script

The final piece is a bash script that ties everything together. I run this continuously in a terminal window, and it rebuilds the library in real-time as I make changes:

```bash
#!/bin/bash
# watch-and-build.sh

RUST_PROJECT_PATH="./game-core"
UNITY_PROJECT_PATH="./unity-project"

# Initial build
./build-all-platforms.sh

# Watch for changes and rebuild
fswatch -o $RUST_PROJECT_PATH/src | while read num ; do
    echo "Changes detected, rebuilding..."
    ./auto-reload-dll.sh
    echo "Ready for testing in Unity"
done
```

This gives me the holy grail: I can work primarily in my Rust codebase with all my usual tools (LSP, tests, etc.), and whenever I want to see the visual result, I just tab over to Unity where the changes are already loaded.

## The API boundary

The interface between Rust and Unity is crucial. I keep it minimal and focused on data exchange:

```rust
// lib.rs
use serde::{Deserialize, Serialize};
use std::ffi::{CStr, CString};
use std::os::raw::c_char;

#[derive(Serialize, Deserialize, Debug)]
pub struct GameState {
    pub score: u32,
    pub level: u32,
    pub entities: Vec<Entity>,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Entity {
    pub id: u32,
    pub x: f32,
    pub y: f32,
    pub entity_type: EntityType,
}

#[derive(Serialize, Deserialize, Debug)]
pub enum EntityType {
    Player,
    Enemy,
    Projectile,
}

// The actual game logic
static mut GAME_STATE: Option<GameState> = None;

#[no_mangle]
pub extern "C" fn initialize_game() {
    unsafe {
        GAME_STATE = Some(GameState {
            score: 0,
            level: 1,
            entities: vec![],
        });
    }
}

#[no_mangle]
pub extern "C" fn update_game(delta_time: f32) {
    unsafe {
        if let Some(ref mut state) = GAME_STATE {
            // Game logic here
            update_entities(state, delta_time);
        }
    }
}

#[no_mangle]
pub extern "C" fn get_game_state() -> *mut c_char {
    unsafe {
        if let Some(ref state) = GAME_STATE {
            let json = serde_json::to_string(state).unwrap();
            CString::new(json).unwrap().into_raw()
        } else {
            std::ptr::null_mut()
        }
    }
}

// Don't forget to free the string!
#[no_mangle]
pub extern "C" fn free_string(ptr: *mut c_char) {
    unsafe {
        if !ptr.is_null() {
            CString::from_raw(ptr);
        }
    }
}

fn update_entities(state: &mut GameState, delta_time: f32) {
    // Your game logic here
    for entity in &mut state.entities {
        match entity.entity_type {
            EntityType::Player => {
                // Player update logic
            }
            EntityType::Enemy => {
                // Enemy update logic
            }
            EntityType::Projectile => {
                // Projectile update logic
            }
        }
    }
}
```

## The development workflow

With all this in place, my typical workflow looks like:

1. **Start the watch script** in a terminal
2. **Work in Rust** with full IDE support, running tests as I go
3. **Switch to Unity** when I want to see visual results
4. **Changes are automatically loaded** â€“ no manual steps needed

The feedback loop is incredibly fast. I can make a change in Rust, hit save, and within seconds see the result in Unity. It's the best of both worlds: the development experience of Rust with the visual capabilities of Unity.

## Testing the core

One of the biggest advantages of this setup is that I can thoroughly test the game logic in isolation:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_player_movement() {
        let mut state = GameState {
            score: 0,
            level: 1,
            entities: vec![Entity {
                id: 1,
                x: 0.0,
                y: 0.0,
                entity_type: EntityType::Player,
            }],
        };

        // Test movement logic
        update_entities(&mut state, 0.016); // 60 FPS
        
        // Assert expected state changes
        assert_eq!(state.entities[0].x, 0.1);
    }

    #[test]
    fn test_collision_detection() {
        // Test collision logic without any rendering
    }

    #[test]
    fn test_game_rules() {
        // Test win/lose conditions
    }
}
```

I can run `cargo test` and get instant feedback on my game logic, completely separate from Unity.

## What's next?

This setup has been working great for me, but there are still improvements to make:

- **Better error handling** between the Rust/Unity boundary
- **Performance profiling** to identify bottlenecks
- **More sophisticated state synchronization** for complex games
- **Hot-reloading of game assets** (textures, sounds, etc.)

The most important thing is that this approach has solved my original problem: I can now develop games with the tooling I love, while still having access to Unity's mature ecosystem for the visual aspects.

## Final thoughts

Is this overkill for most games? Probably. But for certain types of games â€“ especially those with complex logic that benefits from thorough testing â€“ this hybrid approach offers compelling advantages.

The key is recognizing that you don't have to choose between Rust and Unity. Sometimes the best solution is to use both tools for what they're best at.

---

*Have you tried similar hybrid approaches? I'd love to hear about your experiences and improvements to this setup. Feel free to reach out!*

TODO: Add links to the complete example project on GitHub
TODO: Add discussion section or comments 
